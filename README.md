Ответы на вопросы после заданий.

Задание 1:

1. Расскажите как работает файловое кеширование в шаблонах компонентов. Где стартует, где
заканчивается

Компонент работатет по следующему принципу:

1. Проверка входных данных в component.php.
2. Проверка на наличие валидного (активного) кеша файлов result_modifier.php и template.php. Если кеш валидный, то вывод html, воссоздание массива $arResult с ключами из вызова SetResultCacheKeys() и переход к пункту 5.
3. В случае невалидного кеша производятся необходимые действия для получения данных, т.е. заполнение массива $arResult.
4. Подключение файлов result_modifier.php и template.php, формирование + вывод html, а также сохранение в кеше вывода и части массива $arResult.
5. Подключение файла component_epilog.php.
6. Выполнение остального кода в component.php.

Кеширование начинается с класса, реализующего логику работы компонента, затем подключается файл result_modifier, в котором можно обработать данные, написать тяжелую логику и внести в кеш. Затем происходит подключение шаблона, с html содержимым в котором вывод его также сохраняется в кеш. На этом кеширование заканчивается. После чего подключается файл эпилог компонента, в котором можно дополнить логику работы компонента и вызвать отложенные функции. 

2. Почему нельзя использовать глобальные переменные в кешируемой области?

Потому что значение глобальной переменной может быть изменено на других страницах, поэтому мы не можем быть уверены, что при вызове нужной страницы данные будут которые нам нужны, а также при таких изменениях переменной, будет создаваться новый файл кеша, тем самым засоряя память.

3. Как поместить в кеш свою переменную?

Используя PHPCache старого ядра
$cache = new CPHPCache();
if ($cache->InitCache($cacheTime, $cacheId, $cacheDir))
{
    $result = $cache->GetVars();
}
elseif($cache->StartDataCache())
{
    $result = array();
    // ...
    if ($isInvalid)
    {
        $cache->AbortDataCache();
    }
    // ...
    $cache->EndDataCache($result);
}

// D7
$cache = Bitrix\Main\Data\Cache::createInstance();
if ($cache->initCache($cacheTime, $cacheId, $cacheDir))
{
    $result = $cache->getVars();
}
elseif ($cache->startDataCache())
{
    $result = array();
    // ...
    if ($isInvalid)
    {
        $cache->abortDataCache();
    }
    // ...
    $cache->endDataCache($result);
}


Задание 2:
1. Как работают события в Bitrix FW?

В первую очередь должна быть написана функция, в которой будет проиходить обработка определенного события, также можно использовать анонимные функции при регистрации событий. Затем, необходимо зарегестрировать функцию в обработчике событий. Используя регистрацию событий при установке модуля или в файле init.php. После чего событие будет отслеживаться в системе.

2. Как управлять очерёдностью выполнения хэндлеров одного и того же события?

При добавлении обработчика события, в методе addEventHandler имеется 4 параметр - sort, отвечающий за очередность выполнения. по умолчанию значение 100

3. В чём отличие событий зарегистрированными модулем, и просто в моменте жизненного цикла приложения?

События зарегистрированные модулем проиходят регистрацию в базе данных, а события в моменте жизненного цикла в файле init.php.
События зарегистрированные модулем работают с обработчиками модуля, а а события в моменте жизненного цикла - с обработчиками вне модулей

4. Как узнать, есть ли событие при работе с тем или иным методом апи?

GetModuleEvents - Возвращает список обработчиков события event_id модуля module_id в виде объекта класса CDBResult. Аналог метода в новом ядре: Bitrix\Main\EventManager::findEventHandlers.